module MiniC-ContextFree

	imports
		MiniC-Lexical
//exports 

	//sorts
		//Program TypeDec VarDec ArrayType Type FunctionDec FormalList FormalRest Parameter Statement Exp ExpList ExpRest

 
	templates
		Program.Program						= < <TypeDec*> <VarDec*> <FunctionDec*> <Exp> >
		
		TypeDec.StructDec					= < struct <ID> { <VarDec*> } ; >

	 	VarDec.IDDec						= < <Type> <ID> ; >
		VarDec.ArrayDec						= < <ArrayType> <ID> [ <INT> ] ; >
		
	
		FunctionDec.FunctionDec				= < <Type> <ID> ( <FormalList> ) { <VarDec*> <Statement*> return <Exp> ; } >
		
		FormalList.List						= < <Parameter> <FormalRest*> >
		FormalList.EmptyList				= <  >
		FormalRest.ListRest					= < , <Parameter> >
		
		Parameter.IDParameter				= < <Type>  <ID> >
		Parameter.ArrayParameter			= < <ArrayType>  <ID> [ ] >
		
		ArrayType.IntArray					= < int >
		ArrayType.FloatArray				= < float >
		Type.ArrayType						= < <ArrayType> >
		Type.StructType						= < struct <ID>  >

		Statement.IDAssignment				= < <ID> = <Exp> ; >
		Statement.ArrayAssignment			= < <ID> [ <Exp> ] = <Exp> ; >
		Statement.StructMemberAssignment	= < <ID> . <ID> = <Exp> ; >
		Statement.IfElse					= < if ( <Exp> ) <Statement> else <Statement> >
		Statement.While						= < while ( <Exp> ) <Statement> >
		Statement.PrintfInt					= < printf ( "%i" , <Exp> ) ; >
		Statement.PrinfFloat				= < printf ( "%f" , <Exp> ) ; >
		Statement.Block						= < { <Statement*> } >


		//Exp.Uminus						= < - <INT> >
		Exp.INTExp							= < <INT> >
		Exp.FLOATExp						= < <FLOAT> >
		//Exp.IDExp						 	= < <ID> >
		
		Lvalue.IDExp					 	= < <ID> >
		Lvalue.StructMemberExp				= < <Lvalue> . <Lvalue> > {left}
		Lvalue.ArrayExp						= < <ID> [ <Exp> ] >
		
		Exp 								= < <Lvalue> >
		
		Exp.And								= < <Exp> && <Exp> > {left}
		Exp.Lt								= [ [Exp] < [Exp] ] {non-assoc}
		Exp.Gt								= [ [Exp] > [Exp] ] {non-assoc}
		Exp.Add								= < <Exp> + <Exp> > {left}
		Exp.Subtract						= < <Exp> - <Exp> > {left}
		Exp.Multiply						= < <Exp> * <Exp> > {left}
		Exp.Divide							= < <Exp> / <Exp> > {left}
		Exp.Not								= < ! <Exp> >
		Exp									= < ( <Exp> ) > {bracket}
		Exp.Sizeof							= < sizeof ( <Exp> ) >
		Exp.FunctionCall					= < <ID> ( <ExpList> ) >
  
		ExpList.ListExp						= < <Exp> <ExpRest*> >
		ExpList.EmptyListExp				= <  >
		ExpRest.ListRestExp					= < , <Exp> >

	
	context-free priorities

  		/*{
  			Lvalue.ArrayExp
  			//Exp.FunctionCall
  		} > { 
  			Lvalue.StructMemberExp
  		} > */
  		{ left:
  			Exp.Multiply
  			Exp.Divide
  		} >	{ left:
  			Exp.Add
  			Exp.Subtract
  		} > { non-assoc:
  			Exp.Lt
  			Exp.Gt
  		} > { left:
  			Exp.And
  		}
  		
  	template options
  		keyword -/- [a-zA-Z]
  	
  	
  	