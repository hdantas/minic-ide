module editor/outline

imports
  include/MiniC
  runtime/editor/outline-library
  runtime/editor/origins
  runtime/editor/editor
  
  // editor/MiniC-Outliner.generated
  
  
rules
  // outline = simple-label-outline(to-outline-label)
  outline = custom-label-outline(to-outline-label, to-outline-node)
  outline-expand-to-level = !3
     
rules

  to-outline-label: File(t, v, f, e) -> <origin-file; base-filename> // file name
  // to-outline-label: File(t, v, f, e) -> <origin-file> // full path

//    class declarations,
  to-outline-label: StructDec(i, m) -> $[struct: [i]]

//    field declarations and
  to-outline-label: VarDec(t, i) -> $[[<pp> t]: [i]]
  to-outline-label: ArrayDec(t, i, n) -> $[[<pp> t] array: [i]]

//    method declarations.
  to-outline-label: FunctionDef(t, i, p, v, s, e) -> label
  where
      t'     := <pp> t
      ;list  := <pp-params> p
      ;label := $[[t']: [i] ([list])]

  // to-outline-node: StructDec(i, m) -> Node(i, [Node("dummy", [])])
  to-outline-node: File (t, _, f, _) -> outer-node
  where
    inner-node := <get-node> f
    ;outer-node := Node(<get-name> t, <get-2name> t)


  
  get-name: [StructDec(i, _)] -> <to-outline-label> i
  get-2name: [StructDec(_, children)] -> children
  
  // get-name: [StructDec(i, _)] -> i
  get-node: [param] -> Node(<to-outline-label> param, [])
  
  // to-outline-label: ... -> ...
  // to-outline-label: Var(i) -> $[var: [i]] 
  
rules
      
  pp: Int()        -> "int"
  pp: Float()      -> "float"
  pp: ArrayInt()     -> label
  where
  	brackets := "[]"
  	;label := $[int [brackets]]
  		 	
  pp: ArrayFloat()     -> label
  where
  	brackets := "[]"
  	;label := $[float [brackets]]
  	 		 	
  pp: Struct(t)    -> t


  pp-params: // empty parameter list
    [] -> " "

  pp-params: // single parameter
    [Arg(t, n)] -> <pp> t
  
  pp-params: // single parameter array  
    [ArrayArg(t, n)] -> <pp> t


  pp-params: // at least two parameters
    [Arg(t, p), param | params] -> label
    where
      e1     := <pp> t // do something on first parameter
      ;list  := <pp-params> [param | params] // recursive call on remaining parameters
      ;label := $[[e1], [list]] // generate label

  pp-params: // at least two parameters
    [ArrayArg(t, n), param | params] -> label
    where
      e1     := <pp> t // do something on first parameter
      ;list  := <pp-params> [param | params] // recursive call on remaining parameters
      ;label := $[[e1], [list]] // generate label

rules

  //to-outline-label: Assignment(t, v) -> v
  