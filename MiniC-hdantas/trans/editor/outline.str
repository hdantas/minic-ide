module editor/outline

imports
  include/MiniC
  runtime/editor/outline-library
  runtime/editor/origins
  // editor/MiniC-Outliner.generated
  
  
rules
  outline = simple-label-outline(to-outline-label)
  outline-expand-to-level = !3

rules
  to-outline-label: File(t, v, f, e) -> $[Program]

//    class declarations,
  to-outline-label: StructDec(i, m) -> $[struct: [i]]

//    field declarations and
  to-outline-label: VarDec(t, i) -> $[[<pp> t]: [i]]
  to-outline-label: ArrayDec(t, i, n) -> $[[<pp> t] array: [i]]

//    method declarations.
  to-outline-label: FunctionDef(t, i, p, v, s, e) -> label
  where
      t'     := <pp> t
      ;list  := <pp-params> p
      ;label := $[[t']: [i] ([list])]

  // to-outline-label: ... -> ...
  // to-outline-label: Var(i) -> $[var: [i]] 
  
rules
      
  pp: Int()        -> "int"
  pp: Float()      -> "float"
  pp: ArrayInt()     -> label
  where
  	brackets := "[]"
  	;label := $[int [brackets]]
  		 	
  pp: ArrayFloat()     -> label
  where
  	brackets := "[]"
  	;label := $[float [brackets]]
  	 		 	
  pp: Struct(t)    -> t


  pp-params: // empty parameter list
    [] -> " "

  pp-params: // single parameter
    [Arg(t, n)] -> <pp> t
  
  pp-params: // single parameter array  
    [ArrayArg(t, n)] -> <pp> t


  pp-params: // at least two parameters
    [Arg(t, p), param | params] -> label
    where
      e1     := <pp> t // do something on first parameter
      ;list  := <pp-params> [param | params] // recursive call on remaining parameters
      ;label := $[[e1], [list]] // generate label

  pp-params: // at least two parameters
    [ArrayArg(t, n), param | params] -> label
    where
      e1     := <pp> t // do something on first parameter
      ;list  := <pp-params> [param | params] // recursive call on remaining parameters
      ;label := $[[e1], [list]] // generate label

rules

  //to-outline-label: Assignment(t, v) -> v
  