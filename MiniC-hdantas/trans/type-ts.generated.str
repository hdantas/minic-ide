module trans/type-ts.generated

imports
  lib/runtime/nabl/-
  lib/runtime/task/-
  lib/runtime/types/-
  lib/runtime/properties/-
  
  
rules
  
  create-type-task(|ctx) :
    IntConst(v) -> <type-is(|ctx, [])> Int()
    where id
  
  create-type-task(|ctx) :
    FloatConst(f) -> <type-is(|ctx, [])> Float()
    where id
  
  create-type-task(|ctx) :
    UnExp(op, e1) -> <type-is(|ctx, [t2, expected-type, return-type, e1-type, eq8])> return-type
    where t2 := <type-task(|ctx)> op;
          expected-type := <new-task(|ctx)> Rewrite("proj6", t2);
          return-type := <new-task(|ctx)> Rewrite("proj7", t2);
          e1-type := <type-task(|ctx)> e1;
          eq8 := <type-match(|ctx, e1-type)> expected-type;
          <task-create-error-on-failure(|ctx, eq8, ["Unexpected subexpression type for unary operator. Received ", e1-type, " expecting ", expected-type, "."])> e1
  
  create-type-task(|ctx) :
    UMINUS() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    UPLUS() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    UNOT() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    USIZEOF() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    BinExp(op, e1, e2) -> <type-is(|ctx, [t3, expected-type, return-type, e1-type, e2-type, eq9, eq10])> return-type
    where t3 := <type-task(|ctx)> op;
          expected-type := <new-task(|ctx)> Rewrite("proj4", t3);
          return-type := <new-task(|ctx)> Rewrite("proj5", t3);
          e1-type := <type-task(|ctx)> e1;
          e2-type := <type-task(|ctx)> e2;
          eq9 := <type-match(|ctx, e1-type)> expected-type;
          <task-create-error-on-failure(|ctx, eq9, ["Unexpected 1st subexpression type for unary operator. Received ", e1-type, " expecting ", expected-type, "."])> e1;
          eq10 := <type-match(|ctx, e2-type)> expected-type;
          <task-create-error-on-failure(|ctx, eq10, ["Unexpected 2nd subexpression type for unary operator. Received ", e2-type, " expecting ", expected-type, "."])> e2
  
  create-type-task(|ctx) :
    Plus() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    Minus() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    Mul() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    And() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    Lt() -> <type-is(|ctx, [])> (Int(), Int())
    where id
  
  create-type-task(|ctx) :
    Var(i) -> <type-is(|ctx, [ty])> ty
    where ty := <type-lookup(|ctx)> i
  
  create-type-task(|ctx) :
    StructMember(v, Field(f)) -> <type-is(|ctx, [ty])> ty
    where ty := <type-lookup(|ctx)> f
  
  create-type-task(|ctx) :
    StructMember(v, ArrayField(f, e)) -> <type-is(|ctx, [ty])> ty
    where ty := <type-lookup(|ctx)> f
  
  create-type-task(|ctx) :
    Arg(t, p) -> <type-is(|ctx, [])> t
    where id
  
  create-type-task(|ctx) :
    ArrayArg(t, p) -> <type-is(|ctx, [])> t
    where id
  
  nabl-constraint(|ctx) :
    Assignment(v, e) -> <fail>
    where type-e := <type-task(|ctx)> e;
          type-v := <type-task(|ctx)> v;
          subtype2 := <create-subtype-task(|ctx)>("<:", type-v, type-e);
          <task-create-error-on-failure(|ctx, subtype2, ["Assigning expression of type ", type-e, " to variable of type ", type-v, "."])> e
  
  nabl-constraint(|ctx) :
    IfElse(e, a, b) -> <fail>
    where type := <type-task(|ctx)> e;
          eq11 := <type-match(|ctx, Int())> type;
          <task-create-error-on-failure(|ctx, eq11, ["If statement requires an Int. Received ", type, "."])> e
  
  nabl-constraint(|ctx) :
    While(e, b) -> <fail>
    where type := <type-task(|ctx)> e;
          eq12 := <type-match(|ctx, Int())> type;
          <task-create-error-on-failure(|ctx, eq12, ["While statement requires an Int. Received ", type, "."])> e
  
  nabl-constraint(|ctx) :
    PrintfInt(e) -> <fail>
    where type := <type-task(|ctx)> e;
          eq13 := <type-match(|ctx, Int())> type;
          <task-create-error-on-failure(|ctx, eq13, ["%i expects an Int. Received ", type, "."])> e
  
  nabl-constraint(|ctx) :
    PrintfFloat(e) -> <fail>
    where type := <type-task(|ctx)> e;
          eq14 := <type-match(|ctx, Float())> type;
          <task-create-error-on-failure(|ctx, eq14, ["%f expects a Float. Received ", type, "."])> e
  
  nabl-constraint(|ctx) :
    FunctionDef(t, a, b, c, r) -> <fail>
    where ret-type := <type-lookup(|ctx)> r;
          subtype3 := <create-subtype-task(|ctx)>("<:", t, ret-type);
          <task-create-error-on-failure(|ctx, subtype3, ["Unexpect type for returning expression: ", ret-type, ". Expecting ", t, "."])> r
  
  create-subtype-task(|ctx) :
    ("<:", ty1, ty2) -> eq15
    where eq15 := <type-match(|ctx, ty2)> ty1
  
  
rules // projections
  
  task-rewrite :
    ("proj7", (expected-type, return-type)) -> return-type
  
  task-rewrite :
    ("proj6", (expected-type, return-type)) -> expected-type
  
  task-rewrite :
    ("proj5", (expected-type, return-type)) -> return-type
  
  task-rewrite :
    ("proj4", (expected-type, return-type)) -> expected-type
  
