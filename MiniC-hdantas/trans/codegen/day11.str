module codegen/day11

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT
  trans/codegen/challenges
  
rules // STRUCT
    
  // StructDec("foo", [FieldDec(Int(), "a")])
rules // STATEMENTS 
  
  // Recursive call when multiple statements exist
  stmt-to-jbc: [s, t | ts] -> instr*
  with
    head-stmt* := <stmt-to-jbc> s
  ; tail-stmt* := <stmt-to-jbc> [t | ts]
  ; instr*     := [head-stmt*, tail-stmt*]
  
  stmt-to-jbc: [s] -> [<stmt-to-jbc> s]
  stmt-to-jbc: []  -> []
  

  stmt-to-jbc: CodeBlock(c) -> [<stmt-to-jbc> c]

  stmt-to-jbc: IfElse(cond, if-stmt, else-stmt) -> instr*
  with
    else-label := [<newname>]
  ; end-label  := [<newname>]
  ; instr*     := [
      [<exp-to-jbc> cond]
    , IFEQ(LabelRef(else-label))
    , [<stmt-to-jbc> if-stmt]
    , GOTO(LabelRef(end-label))
    , JBCLabel(else-label)
    , [<stmt-to-jbc> else-stmt]
    , JBCLabel(end-label)
    ]
            
  stmt-to-jbc: While(cond, stmt) -> instr*
  with
    cond-label := [<newname>]
  ; loop-label := [<newname>]
  ; end-label  := [<newname>]
  ; instr*     := [
    GOTO(LabelRef(cond-label))
    , JBCLabel(loop-label)
    , [<stmt-to-jbc> stmt]
    , JBCLabel(cond-label)
    , [<exp-to-jbc> cond]
    , IFNE(LabelRef(loop-label))
    , JBCLabel(end-label)
    ]

rules // EXPRESSIONS
	
	// recursive call for multiple expressions
  exp-to-jbc: [e, t | ts] -> instr*
  with
    head-exp* := <exp-to-jbc> e
  ; tail-exp* := <exp-to-jbc> [t | ts]
  ; instr*    := [head-exp*, tail-exp*]
  
  exp-to-jbc: [e] -> [<exp-to-jbc> e]
  exp-to-jbc: []  -> []   
    
  // Unary Expressions
  exp-to-jbc: UnExp(uop, e) -> instr*
  with
    instr* := <op-to-jbc> UnExp(uop, e)

  // Unary Operators
  op-to-jbc: UnExp(UPLUS(), e)  -> <exp-to-jbc> e
  
  op-to-jbc: UnExp(UMINUS(), e)  -> instr*
  with
    exp*   := <exp-to-jbc> e
  ; instr* := [LDC("0"), exp*, ISUB()]
  
  op-to-jbc: UnExp(UNOT(), e)  -> instr*
  with
    true-label  := <newname>
  ; false-label := <newname>
  ; end-label   := <newname>
  ; instr*      := [
      <exp-to-jbc> e
    , IFNE(LabelRef(false-label))
    , ICONST_1()
    , GOTO(LabelRef(end-label))
    , JBCLabel(false-label)
    , ICONST_0()
    , JBCLabel(end-label)
  ]
    
  op-to-jbc: UnExp(USIZEOF(), e) -> ["TODO USIZEOF()"] // TODO

  // Binary Expressions
  exp-to-jbc: BinExp(bop, e1, e2) -> instr*
  with
  instr* := <op-to-jbc> BinExp(bop, e1, e2)
 
  // Binary Operators
  op-to-jbc: BinExp(Plus(), e1, e2) -> instr*
  with
  	exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, IADD()]
  
  op-to-jbc: BinExp(Minus(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, ISUB()]
     
  op-to-jbc: BinExp(Mul(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, IMUL()]
    
  op-to-jbc: BinExp(And(), e1, e2) -> ["TODO AND()"] //TODO Lazy-way
  
  op-to-jbc: BinExp(Lt(), e1, e2) -> instr*
  with
    false-label := <newname>
  ; end-label   := <newname>  
  ; instr*      := [
      <exp-to-jbc> e1
    , <exp-to-jbc> e2
    , IF_ICMPGE(LabelRef(false-label))
    , ICONST_1()
    , GOTO(LabelRef(end-label))
    , JBCLabel(false-label)
    , ICONST_0()
    , JBCLabel(end-label)
    ]

rules // FUNCTIONS/METHODS

  // recursive call for multiple functions
  function-to-jbc: [f, t | ts] -> instr*
  with
    head-fun* := <function-to-jbc> f
  ; tail-fun* := <function-to-jbc> [t | ts]
  ; instr*    := [head-fun*, tail-fun*]
  
  function-to-jbc: [f] -> [<function-to-jbc> f]
  function-to-jbc: [] -> []
  
  // function without parameters or local variables
  function-to-jbc: FunctionDef(t, i, p, s, e) -> instr*
  with
    types  := [PUBLIC(), STATIC()]
  ; descr  := <get-descriptor> i
  ; stmts* := <stmt-to-jbc> s
  ; instr* := Function-Constructor(types, i, descr, stmts*)
  
  exp-to-jbc: Call(c, e) -> instr*
  with
    // descr := <get-descriptor> c
    descr := [JBCMethodDesc([Void()], Void())]
  ; instr* := [INVOKEVIRTUAL(
      JBCMethodRef(
        CRef("example/HelloWorld")
      , MRef(c)
      , descr
      )
    )]
  
    

    
    
 