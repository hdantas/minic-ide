module trans/codegen/stmt

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT
  
  trans/codegen/type
  trans/codegen/exp

rules

  stmt-to-jbc: PrintfInt(i)   -> Printf(Int(), <exp-to-jbc> i)
  stmt-to-jbc: PrintfFloat(f) -> Printf(Float(), <exp-to-jbc> f)


    // StructDec("foo", [FieldDec(Int(), "a")])
rules // STATEMENTS 
  
  // Recursive call when multiple statements exist
  stmt-to-jbc: [s, t | ts] -> instr*
  with
    head-stmt* := <stmt-to-jbc> s
  ; tail-stmt* := <stmt-to-jbc> [t | ts]
  ; instr*     := [head-stmt*, tail-stmt*]
  
  stmt-to-jbc: [s] -> [<stmt-to-jbc> s]
  stmt-to-jbc: []  -> []
  

  stmt-to-jbc: CodeBlock(c) -> [<stmt-to-jbc> c]

  stmt-to-jbc: IfElse(cond, if-stmt, else-stmt) -> instr*
  with
    else-label := [<newname>]
  ; end-label  := [<newname>]
  ; instr*     := [
      <exp-to-jbc> [cond]
    , IFEQ(LabelRef(else-label))
    , <stmt-to-jbc> [if-stmt]
    , GOTO(LabelRef(end-label))
    , JBCLabel(else-label)
    , <stmt-to-jbc> [else-stmt]
    , JBCLabel(end-label)
    ]
            
  stmt-to-jbc: While(cond, stmt) -> instr*
  with
    cond-label := [<newname>]
  ; loop-label := [<newname>]
  ; end-label  := [<newname>]
  ; instr*     := [
    GOTO(LabelRef(cond-label))
    , JBCLabel(loop-label)
    , <stmt-to-jbc> [stmt]
    , JBCLabel(cond-label)
    , <exp-to-jbc> [cond]
    , IFNE(LabelRef(loop-label))
    , JBCLabel(end-label)
    ]
 
    
rules // Generate Code for Local Variables and Variable Access

stmt-to-jbc: VarDec(Struct(ty), name) -> instr
  with
    descript := <type-to-jbc> Struct(ty)
  ; instr    := [JBCField([PRIVATE()], name, descript, None(), None())]
    
  stmt-to-jbc: VarDec(ty, name) -> instr
  with
    descript := JBCFieldDesc(<type-to-jbc> ty)
  ; instr    := [JBCField([PRIVATE()], name, descript, None(), None())]


rules //assignments Assignment(Var("a"), IntConst("1"))
  
  stmt-to-jbc: Assignment(StructMember(var, field), ArrayVar(array, index)) -> instr* //array assignments to fields
  with 
    fieldaccess  := <exp-to-jbc> StructMember(var, field)
  ; arrayaccess  := <exp-to-jbc> Var(array)
  ; indexaccess* := [<exp-to-jbc> index, IALOAD()]
  ; instr*       := [GETFIELD(arrayaccess), indexaccess*, PUTFIELD(fieldaccess)]
    
  stmt-to-jbc: Assignment(StructMember(var, field), exp) -> instr*  //assignments to fields
  with
    fieldaccess := <exp-to-jbc> StructMember(var, field)
  ; expaccess   := <exp-to-jbc> exp
  ; instr*      := [<get-field-or-const> [exp, expaccess], PUTFIELD(fieldaccess)]

  stmt-to-jbc: Assignment(var, exp) -> instr
  with
    expaccess := <exp-to-jbc> exp
  ; varaccess := <exp-to-jbc> var
  ; instr     := [<get-field-or-const> [exp, expaccess], PUTFIELD(varaccess)]
    
rules // auxiliary
  get-field-or-const: [IntConst(_), jbc] -> jbc // dont use GETFIELD() for constants 
  get-field-or-const: [FloatConst(_), jbc] -> jbc
  get-field-or-const: [var, jbc] -> GETFIELD(jbc)
  
overlays

  Printf(type, i) = //printfInt or printfFloat
  [
    [GETSTATIC(
      JBCFieldRef(
        CRef("java/lang/System")
      , FRef("out")
      , JBCFieldDesc(Reference(CRef("java/io/PrintStream")))
      )
    )] // push System.out onto the stack
  , [i] // push a string onto the stack
  , [INVOKEVIRTUAL(
      JBCMethodRef(
        CRef("java/io/PrintStream")
      , MRef("println")
      , JBCMethodDesc(type, Void())
      )
    )]
  ]