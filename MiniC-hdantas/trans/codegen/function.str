module trans/codegen/function

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT
  
  trans/codegen/stack
  trans/codegen/type
  trans/codegen/exp
  trans/codegen/array
  trans/codegen/stmt
  
rules

  // recursive call for multiple functions
  function-to-jbc: [FunctionDef(ty, i, p, s, e) | ts] -> instr*
  with
    head-fun* := <function-to-jbc> FunctionDef(ty, i, p, s, e)
  ; tail-fun* := <function-to-jbc> ts
  ; instr*    := [head-fun*, tail-fun*]
  
  function-to-jbc: [] -> []
  
  // function without parameters or local variables
  function-to-jbc: FunctionDef(t, i, p, s, e) -> instr*
  with
    types         := [PUBLIC()]
  ; stack-limit*  := <stack-limit> (p, s, e)
  ; descr*        := <get-method-descriptor> i
  ; stmts-ln      := <stmt-to-jbc-ln; flatten-list> s
  ; stmts*        :=  <linenumber-cleanup; Third> ([], stmts-ln, []) //no more duplicate lines
  ; return-jbc*   := <return-aux> (e, <get-type> e)
  ; method-stmts* := [stack-limit*, stmts*, return-jbc*]
  ; instr*        := Function-Constructor(types, i, descr*, method-stmts*)
  

	testingcenas(|list): [t | ts] -> ""
	with
	  <debug> "testing"
	; <debug> list
	; <testingcenas(| <concat> [[t], list])> ts
	 	
overlays

  Function-Constructor(types, name, descr, stmts) =
  [
    JBCMethod(
      types
    , name
    , descr
    , stmts
    )
  ]

rules
	return-aux: (exp, Int()) -> instr*
	with
		jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, IRETURN()]

  return-aux: (exp, Float()) -> instr*
  with
    jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, FRETURN()]
  
  return-aux: (exp, type) -> instr* //struct instance
  with
    jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, ARETURN()]  
    
rules
  nabl-prop-site(|lang, ctx, uris, states, implicits): FunctionDef(ty, mname, param*, stmt*, exp) -> <fail>
  where
    param-type    := <map(param-aux)> param* //type descriptor
  ; descr         := JBCMethodDesc(param-type, <type-to-jbc> ty) 
  ; <store-method-descriptor(|ctx, descr)> mname
  
  ; indexed-param := <map-with-index(id)> param* //parameter indices
  ; <map(map-index(|ctx, 0))> indexed-param
  
  ; number-param  := <length> param*
  ; cleaned-stmt  := <map(nmap-aux); flatten-list> stmt* //remove non-declarations stmts from list
  ; indexed-stmt  := <map-with-index(id)> cleaned-stmt //statement indices
  ; <map(map-index(|ctx, number-param))> indexed-stmt //indices for locals start after args
    
   nmap-aux: VarDec(t1, t2) -> VarDec(t1, t2) 
   nmap-aux: ArrayDec(t1, t2, t3) -> ArrayDec(t1, t2, t3)
   nmap-aux: CodeBlock(s) -> <map(nmap-aux)> s
   nmap-aux: While(_, s) -> <nmap-aux> s
   nmap-aux: IfElse(_, s1, s2) -> instr*
   with
     l1* := <nmap-aux> s1
   ; l2* := <nmap-aux> s2
   ; instr* := [l1*, l2*]
       
   nmap-aux: _ -> []
   
   param-aux: Arg(ty, name) -> <get-type; type-to-jbc> Arg(ty, name)
   param-aux: ArrayArg(ty, name) -> Array(<get-type; type-to-jbc> Arg(ty, name))
     
rules // auxiliary    
  map-index(|ctx, length): (index, Arg(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <var-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
  
  map-index(|ctx, length): (index, VarDec(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <var-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name

  map-index(|ctx, length): (index, ArrayArg(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <array-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
        
  map-index(|ctx, length): (index, ArrayDec(type, name, size)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <array-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
  
  var-index-aux: (index, Int())   -> ([ILOAD(index)], [ISTORE(index)])
  var-index-aux: (index, Float()) -> ([FLOAD(index)], [FSTORE(index)])
  var-index-aux: (index, otherty) -> ([ALOAD(index)], [ASTORE(index)])

  array-index-aux: (index, Int())   -> ([ALOAD(index)], [ASTORE(index)], [IALOAD()], [IASTORE()])
  array-index-aux: (index, Float()) -> ([ALOAD(index)], [ASTORE(index)], [FALOAD()], [FASTORE()])
  
  map-index(|ctx, length): (index, _) -> "" //ignore other statements
  

rules
  // JBCLines cleanup
  
  linenumber-cleanup: (index, [t | ts], jbc*) -> instr
  with
    head-result := <linenumber-cleanup-aux> (index, t)
  ; newindex    := <Fst> head-result
  ; head-jbc*   := <Snd> head-result
  ; new-jbc*    := [jbc*, head-jbc*]
  ; instr       := <linenumber-cleanup> (newindex, ts, new-jbc*)
    
  linenumber-cleanup: (index, [], jbc) -> (index, [], jbc)
  linenumber-cleanup-aux: (index, []) -> (index, [])
  	
  linenumber-cleanup-aux: (index, JBCLine(i)) -> (newindex, instr)
  with
    result   := <if(<elem> (i, index), <add-to-list> (index, []), <add-to-list> (index, [JBCLine(i)]))>
  ; newindex := <Fst> result
  ; instr    := <Snd> result
  
  linenumber-cleanup-aux: (index, instr) -> (index, [instr])
  	
  add-to-list: (index, [JBCLine(i)]) -> (newindex, [JBCLine(i)])
  with
    newindex := <concat> [index, [i]]

  add-to-list: (index, []) -> (index, [])

     
     