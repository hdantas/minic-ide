module trans/codegen/function

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT
  
  trans/codegen/stack
  trans/codegen/type
  trans/codegen/exp
  trans/codegen/array
  trans/codegen/stmt
  
rules

  // recursive call for multiple functions
  function-to-jbc: [FunctionDef(ty, i, p, s, e), t | ts] -> instr*
  with
    head-fun* := <function-to-jbc> FunctionDef(ty, i, p, s, e)
  ; tail-fun* := <function-to-jbc> [t | ts]
  ; instr*    := [head-fun*, tail-fun*]
  
  function-to-jbc: [FunctionDef(t, i, p, s, e)] -> <function-to-jbc> FunctionDef(t, i, p, s, e)
  function-to-jbc: [] -> []
  
  // function without parameters or local variables
  function-to-jbc: FunctionDef(t, i, p, s, e) -> instr*
  with
    types         := [PUBLIC()]
  ; stack-limit*  := <stack-limit> (p, s, e)
  ; descr*        := <get-method-descriptor> i
  ; stmts*        := <stmt-to-jbc-ln> s
  ; return-jbc*   := <return-aux> (e, <get-type> e)
  ; method-stmts* := [stack-limit*, stmts*, return-jbc*]
  ; instr*        := Function-Constructor(types, i, descr*, method-stmts*)
  

overlays

  Function-Constructor(types, name, descr, stmts) =
  [
    JBCMethod(
      types
    , name
    , descr
    , stmts
    )
  ]

rules
	return-aux: (exp, Int()) -> instr*
	with
		jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, IRETURN()]

  return-aux: (exp, Float()) -> instr*
  with
    jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, FRETURN()]
  
  return-aux: (exp, type) -> instr* //struct instance
  with
    jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, ARETURN()]  
    
rules
  nabl-prop-site(|lang, ctx, uris, states, implicits): FunctionDef(ty, mname, param*, stmt*, exp) -> <fail>
  where
    param-type    := <map(param-aux)> param* //type descriptor
  ; descr         := JBCMethodDesc(param-type, <type-to-jbc> ty) 
  ; <store-method-descriptor(|ctx, descr)> mname
  
  ; indexed-param := <map-with-index(id)> param* //parameter indices
  ; <map(map-index(|ctx, 0))> indexed-param
  
  ; number-param  := <length> param*
  ; cleaned-stmt := <retain-all(nmap-aux)> stmt* //remove non-declarations stmts from list
  ; indexed-stmt  := <map-with-index(id)> cleaned-stmt //statement indices
  ; <map(map-index(|ctx, number-param))> indexed-stmt //indices for locals start after args
    
   nmap-aux: VarDec(t1, t2) -> VarDec(t1, t2) 
   nmap-aux: ArrayDec(t1, t2, t3) -> ArrayDec(t1, t2, t3)
   
   param-aux: Arg(ty, name) -> <get-type; type-to-jbc> Arg(ty, name)
   param-aux: ArrayArg(ty, name) -> Array(<get-type; type-to-jbc> Arg(ty, name))
     
rules // auxiliary    
  map-index(|ctx, length): (index, Arg(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <var-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
  
  map-index(|ctx, length): (index, VarDec(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <var-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name

  map-index(|ctx, length): (index, ArrayArg(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <array-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
        
  map-index(|ctx, length): (index, ArrayDec(type, name, size)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <array-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
  
  var-index-aux: (index, Int())   -> ([ILOAD(index)], [ISTORE(index)])
  var-index-aux: (index, Float()) -> ([FLOAD(index)], [FSTORE(index)])
  var-index-aux: (index, otherty) -> ([ALOAD(index)], [ASTORE(index)])

  array-index-aux: (index, Int())   -> ([ALOAD(index)], [ASTORE(index)], [IALOAD()], [IASTORE()])
  array-index-aux: (index, Float()) -> ([ALOAD(index)], [ASTORE(index)], [FALOAD()], [FASTORE()])
  
  map-index(|ctx, length): (index, _) -> "" //ignore other statements
  

