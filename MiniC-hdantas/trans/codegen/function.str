module trans/codegen/function

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT
  
  trans/codegen/stack
  trans/codegen/type
  trans/codegen/exp
  trans/codegen/array
  trans/codegen/stmt
  
rules

  // recursive call for multiple functions
  function-to-jbc: [FunctionDef(ty, i, p, s, e) | ts] -> instr*
  with
    head-fun* := <function-to-jbc> FunctionDef(ty, i, p, s, e)
  ; tail-fun* := <function-to-jbc> ts
  ; instr*    := [head-fun*, tail-fun*]
  
  function-to-jbc: [] -> []
  
  // function without parameters or local variables
  function-to-jbc: FunctionDef(t, i, p, s, e) -> instr*
  with
    types         := [PUBLIC()]
  ; stack-limit*  := <stack-limit> (p, s, e)
  ; descr*        := <get-method-descriptor> i
  ; stmts-ln      := <stmt-to-jbc-ln> s
  ; stmts*        := <linenumber-cleanup; Third> ([], stmts-ln, []) //no more duplicate lines
  ; return-jbc*   := <return-aux> (e, <get-type> e)
  ; method-stmts* := [stack-limit*, stmts*, return-jbc*]
  ; instr*        := Function-Constructor(types, i, descr*, method-stmts*)


overlays

  Function-Constructor(types, name, descr, stmts) =
  [
    JBCMethod(
      types
    , name
    , descr
    , stmts
    )
  ]

rules
	return-aux: (exp, Int()) -> instr*
	with
		jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, IRETURN()]

  return-aux: (exp, Float()) -> instr*
  with
    jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, FRETURN()]
  
  return-aux: (exp, type) -> instr* //struct instance
  with
    jbc-exp* := <exp-to-jbc-ln> exp
  ; instr*   := [jbc-exp*, ARETURN()]  
    
rules
  nabl-prop-site(|lang, ctx, uris, states, implicits): FunctionDef(ty, mname, param*, stmt*, exp) -> <fail>
  where
    param-type    := <map(param-aux)> param* //type descriptor
  ; descr         := JBCMethodDesc(param-type, <type-to-jbc> ty) 
  ; <store-method-descriptor(|ctx, descr)> mname
  ; <debug> "makelist"
  ; aux-list*     := [param*, stmt*, exp]
  ; makelist      := <makelist-aux> aux-list*
  ; indexed-param := <map-with-index(id)> param* //parameter indices
  ; <map(map-index(|ctx, 0))> indexed-param
  
  ; number-param  := <length> param*
  ; cleaned-stmt  := <map(nmap-aux); flatten-list> stmt* //remove non-declarations stmts from list
  ; indexed-stmt  := <map-with-index(id)> cleaned-stmt //statement indices
  ; <map(map-index(|ctx, number-param))> indexed-stmt //indices for locals start after args
    
   nmap-aux: VarDec(t1, t2) -> VarDec(t1, t2) 
   nmap-aux: ArrayDec(t1, t2, t3) -> ArrayDec(t1, t2, t3)
   nmap-aux: CodeBlock(s) -> <map(nmap-aux)> s
   nmap-aux: While(_, s) -> <nmap-aux> s
   nmap-aux: IfElse(_, s1, s2) -> instr*
   with
     l1* := <nmap-aux> s1
   ; l2* := <nmap-aux> s2
   ; instr* := [l1*, l2*]
       
   nmap-aux: _ -> []
   
   param-aux: Arg(ty, name) -> <get-type; type-to-jbc> Arg(ty, name)
   param-aux: ArrayArg(ty, name) -> Array(<get-type; type-to-jbc> Arg(ty, name))
     
rules // auxiliary    
  map-index(|ctx, length): (index, Arg(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <var-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
  
  map-index(|ctx, length): (index, VarDec(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <var-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name

  map-index(|ctx, length): (index, ArrayArg(type, name)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <array-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
        
  map-index(|ctx, length): (index, ArrayDec(type, name, size)) -> ""
  where
    new-index := <add> (length, index)
  ; instr     := <array-index-aux> (new-index, <get-type> name)
  ; <store-var-index(|ctx, instr)> name
  
  var-index-aux: (index, Int())   -> ([ILOAD(index)], [ISTORE(index)])
  var-index-aux: (index, Float()) -> ([FLOAD(index)], [FSTORE(index)])
  var-index-aux: (index, otherty) -> ([ALOAD(index)], [ASTORE(index)])

  array-index-aux: (index, Int())   -> ([ALOAD(index)], [ASTORE(index)], [IALOAD()], [IASTORE()])
  array-index-aux: (index, Float()) -> ([ALOAD(index)], [ASTORE(index)], [FALOAD()], [FASTORE()])
  
  map-index(|ctx, length): (index, _) -> "" //ignore other statements
  

rules
  // JBCLines cleanup
  
  linenumber-cleanup: (index, [t | ts], jbc*) -> instr
  with
    head-result := <linenumber-cleanup-aux> (index, t)
  ; newindex    := <Fst> head-result
  ; head-jbc*   := <Snd> head-result
  ; new-jbc*    := [jbc*, head-jbc*]
  ; instr       := <linenumber-cleanup> (newindex, ts, new-jbc*)
    
  linenumber-cleanup: (index, [], jbc) -> (index, [], jbc)
  linenumber-cleanup-aux: (index, []) -> (index, [])
  	
  linenumber-cleanup-aux: (index, JBCLine(i)) -> (newindex, instr)
  with
    result   := <if(<elem> (i, index), <add-to-list> (index, []), <add-to-list> (index, [JBCLine(i)]))>
  ; newindex := <Fst> result
  ; instr    := <Snd> result
  
  linenumber-cleanup-aux: (index, instr) -> (index, [instr])
  	
  add-to-list: (index, [JBCLine(i)]) -> (newindex, [JBCLine(i)])
  with
    newindex := <concat> [index, [i]]

  add-to-list: (index, []) -> (index, [])

rules
  makelist-aux: list -> []
  with
    rlist := <reverse; strip-annos> list
  ; varref := <varref-aux(|[])> rlist
  ; indices := <reverse; myindex(|[])> varref
    
  varref-aux(|list): [t | ts] -> instr*
  with
    head-result := <varref-aux1(|list)> t
  // ; <strip-annos; debug> ["head-result", head-result]
  ; tail-result* := <varref-aux(|head-result)> ts
  ; instr*       := [head-result, tail-result*]
  // ; <strip-annos; debug> ["final instr", instr*]
  
  varref-aux(|list): [] -> []
    
  varref-aux1(|list): ArrayArg(type, name)       -> <my-remove-from-list(|list)> name
  varref-aux1(|list): Arg(type, name)            -> <my-remove-from-list(|list)> name
  varref-aux1(|list): VarDec(type, name)         -> <my-remove-from-list(|list)> name
  varref-aux1(|list): ArrayDec(type, name, size) -> <my-remove-from-list(|list)> name
  varref-aux1(|list): Var(name)                  -> <my-add-to-list(|list)> name
  varref-aux1(|list): [] -> []
  
  varref-aux1(|list): other -> instr
  with
    // <debug> ["other", <strip-annos> other] ;
    term  := <try(explode-term)> other
  // ; <debug> ["term", <Snd> term]
  ; instr := <Snd; map(varref-aux1(|list)); flatten-list; make-set> term
  // ; <debug> ["instr", instr]
  
  
  
  my-remove-from-list(|list): name -> <remove-all(myequal(|name))> list
  my-add-to-list(|list): member -> <concat; make-set> [list, [member]] //make-set eliminates duplicates
  
  myequal(|name): listmember -> <equal> (name, listmember)
  myelem(|list): listmember  -> <if(
                                  <elem> (listmember, list),
                                  <debug> $[found [listmember]],
                                  <debug> $[missing [listmember]]
                                )>
  
  myindex(|free): list -> newlist
  with
   // result := <filter(myelem(|"a")); debug> ["a"] ;
   newlist := <map(isort-list(LSort(string-gt)); myindex-aux(|[1]))> list
  ; <debug> newlist

  myindex-aux(|i): sublist -> result
  with
    newlist := []
  ; <debug> "i"
  ; <debug> i
  ; newi := <concat> [i, [1, 2, 3]]
  ; result := <myindex-aux-aux(|[])> sublist
  ; <debug> "after"
  ; usedvars := result
  ; <debug> ["sublist", sublist]
  ; <debug> ["result", result]
  // ; <map(myelem(|sublist)); debug> usedvars
      
  myindex-aux-aux(|i): [t|ts] -> result
  with
    <debug> "start"
  ; <debug> $[add [t] to index]
  ; index-list  := <index> (1, i)
  ; oldusedvars := <index> (2, i)
  ; newusedvars := <concat> [oldusedvars, [t]]
  ; newi := [index-list, newusedvars]
  ; result      := <myindex-aux-aux(|newi)> ts
  ; <debug> ["result", result]
    
    
  myindex-aux-aux(|i): ([], usedvars) -> ([], usedvars)