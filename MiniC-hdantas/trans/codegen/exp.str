module trans/codegen/exp

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT

  trans/codegen/type

rules
  exp-to-jbc: IntConst(i)   -> [LDC(i)]
  exp-to-jbc: FloatConst(f) -> [LDC(f)]


// recursive call for multiple expressions
  exp-to-jbc: [e, t | ts] -> instr*
  with
    head-exp* := <exp-to-jbc> e
  ; tail-exp* := <exp-to-jbc> [t | ts]
  ; instr*    := [head-exp*, tail-exp*]
  
  exp-to-jbc: [e] -> [<exp-to-jbc> e]
  exp-to-jbc: []  -> []   
    
  // Unary Expressions
  exp-to-jbc: UnExp(uop, e) -> instr*
  with
    instr* := <op-to-jbc> UnExp(uop, e)

  // Unary Operators
  op-to-jbc: UnExp(UPLUS(), e)  -> <exp-to-jbc> e
  
  op-to-jbc: UnExp(UMINUS(), e)  -> instr*
  with
    exp*   := <exp-to-jbc> e
  ; instr* := [LDC("0"), exp*, ISUB()]
  
  op-to-jbc: UnExp(UNOT(), e)  -> instr*
  with
    true-label  := <newname>
  ; false-label := <newname>
  ; end-label   := <newname>
  ; instr*      := [
      <exp-to-jbc> e
    , IFNE(LabelRef(false-label))
    , ICONST_1()
    , GOTO(LabelRef(end-label))
    , JBCLabel(false-label)
    , ICONST_0()
    , JBCLabel(end-label)
  ]
    
  op-to-jbc: UnExp(USIZEOF(), e) -> ["TODO USIZEOF()"] // TODO

  // Binary Expressions
  exp-to-jbc: BinExp(bop, e1, e2) -> instr*
  with
  instr* := <op-to-jbc> BinExp(bop, e1, e2)
 
  // Binary Operators
  op-to-jbc: BinExp(Plus(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, IADD()]
  
  op-to-jbc: BinExp(Minus(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, ISUB()]
     
  op-to-jbc: BinExp(Mul(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, IMUL()]
    
  op-to-jbc: BinExp(And(), e1, e2) -> instr*
  with
    exp1*     := <exp-to-jbc> e1
  ; end-label := <newname>
  ; instr*    := [
      exp1*
      , DUP()
      , IFEQ(LabelRef(end-label))
      , POP()
      , <exp-to-jbc> e2
      , JBCLabel(end-label) 
    ]
    
    
  op-to-jbc: BinExp(Lt(), e1, e2) -> instr*
  with
    false-label := <newname>
  ; end-label   := <newname>  
  ; instr*      := [
      <exp-to-jbc> e1
    , <exp-to-jbc> e2
    , IF_ICMPGE(LabelRef(false-label))
    , ICONST_1()
    , GOTO(LabelRef(end-label))
    , JBCLabel(false-label)
    , ICONST_0()
    , JBCLabel(end-label)
    ]

  exp-to-jbc: Call(c, e) -> instr*
  with
    // descr := <get-descriptor> c
    args*  := <exp-to-jbc> e
  ; descr  := [JBCMethodDesc([Void()], <get-type> c)]
  ; call*  := [INVOKESTATIC(
      JBCMethodRef(
        CRef("example/HelloWorld")
      , MRef(c)
      , descr
      )
    )]
  ; instr* := [args*, call*]
  
    // StructMember(Var("foo"), Field("a"))
  exp-to-jbc: StructMember(Var(v), Field(f)) -> instr*
  with //GETFIELD(JBCFieldRef(CRef("HelloWorld/innerclasse"), FRef("innervar"), JBCFieldDesc(Int())))
    fielddesc := JBCFieldDesc(<type-to-jbc> Field(f))
  ; fieldref  := FRef(f)
  ; classref  := <type-to-jbc> Var(v)
  ; instr*    := JBCFieldRef(classref, fieldref, fielddesc)
    
    
  exp-to-jbc: Var(v) -> instr
  with
  	fielddesc := JBCFieldDesc(<type-to-jbc> Var(v))
  ;	instr     := JBCFieldRef(CRef("HelloWorld"), FRef(v), fielddesc)