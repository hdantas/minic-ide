module trans/codegen/exp

imports
  libstratego-gpp
  lib/runtime/tmpl/pp
  include/MiniC
  include/MiniC-parenthesize
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/desugar
  analysis/names
  lib/jasmin/JasminXT

  trans/codegen/type

rules
// recursive call for multiple expressions
  exp-to-jbc: [e, t | ts] -> instr*
  with
    head-exp* := <exp-to-jbc> e
  ; tail-exp* := <exp-to-jbc> [t | ts]
  ; instr*    := [head-exp*, tail-exp*]
  
  exp-to-jbc: [e] -> <exp-to-jbc> e
    
  exp-to-jbc: []  -> []   

    
  exp-to-jbc: IntConst(i)   -> [LDC(i)]
  exp-to-jbc: FloatConst(f) -> [LDC(f)]
      
  // Unary Expressions
  exp-to-jbc: UnExp(uop, e) -> instr*
  with
    exp*   := <op-to-jbc> UnExp(uop, e)
  ; instr* := [exp*]

  // Unary Operators
  op-to-jbc: UnExp(UPLUS(), e) -> instr*
  with
  	exp*   := <exp-to-jbc> e
  ; instr* := [exp*]
  
  op-to-jbc: UnExp(UMINUS(), e) -> instr*
  with
    exp*   := <exp-to-jbc> e
  ; instr* := [LDC("0"), exp*, ISUB()]
  
  
  op-to-jbc: UnExp(UNOT(), e)  -> instr*
  with
    false-label := <newname>
  ; end-label   := <newname>
  ; exp*        := <exp-to-jbc> e
  ; instr*      := [
      exp*
    , IFNE(LabelRef(false-label))
    , ICONST_1()
    , GOTO(LabelRef(end-label))
    , JBCLabel(false-label)
    , ICONST_0()
    , JBCLabel(end-label)
  ]
    
  op-to-jbc: UnExp(USIZEOF(), e) -> [NOP()] // TODO

  // Binary Expressions
  exp-to-jbc: BinExp(bop, e1, e2) -> instr*
  with
    exp*   := <op-to-jbc> BinExp(bop, e1, e2)
  ; instr* := [exp*]
   
  // Binary Operators
  op-to-jbc: BinExp(Plus(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, IADD()]
    
  op-to-jbc: BinExp(Minus(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, ISUB()]
     
  op-to-jbc: BinExp(Mul(), e1, e2) -> instr*
  with
    exp1*  := <exp-to-jbc> e1
  ; exp2*  := <exp-to-jbc> e2
  ; instr* := [exp1*, exp2*, IMUL()]
    
  op-to-jbc: BinExp(And(), e1, e2) -> instr*
  with
    exp1*       := <exp-to-jbc> e1
  ; exp2*       := <exp-to-jbc> e2
  ; false-label := <newname>
  ; end-label   := <newname>
  ; instr*      := [
        exp1*
      , IFEQ(LabelRef(false-label))
      , exp2*
      , IFEQ(LabelRef(false-label))
      , ICONST_1()
      , GOTO(end-label)
      , JBCLabel(false-label)
      , ICONST_0()
      , JBCLabel(end-label) 
    ]
    
    
  op-to-jbc: BinExp(Lt(), e1, e2) -> instr*
  with
    true-label := <newname>
  ; end-label  := <newname>
  ; exp1*      := <exp-to-jbc> e1
  ; exp2*      := <exp-to-jbc> e2
  ; instr*     := [
      exp1*
    , exp2*
    , IF_ICMPLT(LabelRef(true-label))
    , ICONST_0()
    , GOTO(LabelRef(end-label))
    , JBCLabel(true-label)
    , ICONST_1()
    , JBCLabel(end-label)
    ]

  exp-to-jbc: Call(c, e) -> instr*
  with
    args* := <exp-to-jbc> e
  ; descr := <get-method-descriptor> c
  ; call* := [INVOKEVIRTUAL(
      JBCMethodRef(
        CRef("HelloWorld")
      , MRef(c)
      , descr
      )
    )]
  ; instr* := [args*, call*]
  
  exp-to-jbc: StructMember(Var(v), Field(f)) -> instr*
  with
    var-jbc*    := <exp-to-jbc> Var(v)
  ; class-name  := $[HelloWorld/[<get-type; get-arguments; index(|1)> Var(v)]]
  ; getter-name := $[get_[f]]
  ; field-type  := <get-type> Field(f)
  ; invoke-get  := INVOKESTATIC(
	    JBCMethodRef(
	      CRef(class-name)
	    , MRef(getter-name)
	    , JBCMethodDesc([Reference(CRef(class-name))], field-type)
	    )
    )
  ; instr*      := [var-jbc*, invoke-get]
    
  exp-to-jbc: ArrayVar(name, index) -> instr //only local vars have indices
  with //ArrayVar("global", IntConst("0"))
    instr := <if(<get-var-index> name, <local-array-to-jbc> (name, index), <global-array-to-jbc> (name, index))>
    
  local-array-to-jbc: (name, index) -> instr* //handles local arrays
  with
    var-index    := <get-var-index> name
  ; load-instr*  := <Fst> var-index //get load instr from index
  ; index-instr* := <exp-to-jbc> index
  ; load-array*  := <Third> var-index
  ; instr*       := [load-instr*, index-instr*, load-array*]
  
  
  global-array-to-jbc: (name, index) -> instr* //handles global arrays
  with
    fielddesc   := <get-field-descriptor> name
  ; load-instr   := GETSTATIC(JBCFieldRef(CRef("HelloWorld"), FRef(name), fielddesc))
  ; index-instr* := <exp-to-jbc> index
  ; load-array*  := <get-type; array-load-aux> name
  ; instr*       := [load-instr, index-instr*, load-array*]
  
  array-load-aux: Int()   -> [IALOAD()]
  array-load-aux: Float() -> [FALOAD()]
  
  
  exp-to-jbc: Var(v) -> instr //only local vars have indices
  with
    instr := <if(<get-var-index> Var(v), <local-var-to-jbc> Var(v), <global-var-to-jbc> Var(v))>
    
  local-var-to-jbc: Var(v) -> instr //handles local vars
  with
    index := <get-var-index> v // fails for non local variables
  ; instr := <Fst> index //get load instr from index
    
  global-var-to-jbc: Var(v) -> instr //handles global vars
  with
    fielddesc := <get-field-descriptor> v
  ;	instr     := [GETSTATIC(JBCFieldRef(CRef("HelloWorld"), FRef(v), fielddesc))]
   	