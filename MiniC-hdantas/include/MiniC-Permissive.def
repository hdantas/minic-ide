definition

module MiniC-ContextFree
imports MiniC-Lexical

exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    [A-Za-z0-9\_]                  -> WATERTOKENSTART     {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
    "*"                            -> WATERTOKENSTAR      {recover, avoid}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               
                                   -> WATEREOF            
    "completion123"                -> COMPLETIONPREFIX    {completion}
    "|#WATERTOKENSTAR|"            -> WATERTOKENSTAR      {completion}
    "|#TypeDec|"                   -> TypeDec             {completion}
    "|#VarDec|"                    -> VarDec              {completion}
    "|#FunctionDec|"               -> FunctionDec         {completion}
    "|#Parameter|"                 -> Parameter           {completion}
    "|#ArrayType|"                 -> ArrayType           {completion}
    "|#Type|"                      -> Type                {completion}
    "|#Statement|"                 -> Statement           {completion}
    "|#Lvalue|"                    -> Lvalue              {completion}
    "|#Exp|"                       -> Exp                 {completion}
    "|#FLOAT|"                     -> FLOAT               {completion}
    "|#Comment|"                   -> Comment             {completion}
    "|#BlockComment|"              -> BlockComment        {completion}
    "|#ID|"                        -> ID                  {completion}

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules             
                                        -> "};"     {recover, cons("INSERTION")}
                                        -> "struct" {recover, cons("INSERTION")}
                                        -> ");"     {recover, cons("INSERTION")}
                                        -> "}"      {recover, cons("INSERTION")}
                                        -> ")"      {recover, cons("INSERTION")}
                                        -> ","      {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules   

  )

  (

  context-free syntax
    TypeDec* VarDec* FunctionDec* Exp                                            -> Program     {cons("File")}
    "struct" ID "{" VarDec* "};"                                                 -> TypeDec     {cons("StructDec")}
    Type ID ";"                                                                  -> VarDec      {cons("VarDec")}
    ArrayType ID "[" INT "];"                                                    -> VarDec      {cons("ArrayDec")}
    Type ID "(" {Parameter ","}* ")" "{" VarDec* Statement* "return" Exp ";" "}" -> FunctionDec {cons("FunctionDef")}
    Type ID                                                                      -> Parameter   {cons("Arg")}
    ArrayType ID "[]"                                                            -> Parameter   {cons("ArrayArg")}
    "int"                                                                        -> ArrayType   {cons("ArrayInt")}
    "float"                                                                      -> ArrayType   {cons("ArrayFloat")}
    "int"                                                                        -> Type        {cons("Int")}
    "float"                                                                      -> Type        {cons("Float")}
    "struct" ID                                                                  -> Type        {cons("Struct")}
    ID "=" Exp ";"                                                               -> Statement   {cons("Assignment")}
    ID "[" Exp "]" "=" Exp ";"                                                   -> Statement   {cons("ArrayAssignment")}
    ID "." ID "=" Exp ";"                                                        -> Statement   {cons("StructMemberAssignment")}
    "if" "(" Exp ")" Statement "else" Statement                                  -> Statement   {cons("IfElse")}
    "while" "(" Exp ")" Statement                                                -> Statement   {cons("While")}
    "printf(" "\"" "%i" "\"" "," Exp ");"                                        -> Statement   {cons("PrintfInt")}
    "printf(" "\"" "%f" "\"" "," Exp ");"                                        -> Statement   {cons("PrinfFloat")}
    "{" Statement* "}"                                                           -> Statement   {cons("CodeBlock")}
    INT                                                                          -> Exp         {cons("IntConst")}
    FLOAT                                                                        -> Exp         {cons("FloatConst")}
    ID                                                                           -> Lvalue      {cons("Var")}
    Lvalue "." Lvalue                                                            -> Lvalue      {cons("StructMember"), left}
    ID "[" Exp "]"                                                               -> Lvalue      {cons("ArrayVar")}
    Lvalue                                                                       -> Exp         
    Exp "&&" Exp                                                                 -> Exp         {cons("And"), left}
    Exp "<" Exp                                                                  -> Exp         {cons("Lt"), non-assoc}
    Exp "+" Exp                                                                  -> Exp         {cons("Add"), left}
    Exp "-" Exp                                                                  -> Exp         {cons("Subtract"), left}
    Exp "*" Exp                                                                  -> Exp         {cons("Multiply"), left}
    "!" Exp                                                                      -> Exp         {cons("Not")}
    "(" Exp ")"                                                                  -> Exp         {bracket}
    "sizeof" "(" Exp ")"                                                         -> Exp         {cons("Sizeof")}
    ID "(" {Exp ","}* ")"                                                        -> Exp         {cons("Call")}
    "-" Exp                                                                      -> Exp         {cons("Uminus")}
    "+" Exp                                                                      -> Exp         {cons("Uplus")}

  context-free syntax
    CONTENTCOMPLETE -> Program     {cons("COMPLETION-Program")}
    CONTENTCOMPLETE -> TypeDec     {cons("COMPLETION-TypeDec")}
    CONTENTCOMPLETE -> VarDec      {cons("COMPLETION-VarDec")}
    CONTENTCOMPLETE -> FunctionDec {cons("COMPLETION-FunctionDec")}
    CONTENTCOMPLETE -> Parameter   {cons("COMPLETION-Parameter")}
    CONTENTCOMPLETE -> ArrayType   {cons("COMPLETION-ArrayType")}
    CONTENTCOMPLETE -> Type        {cons("COMPLETION-Type")}
    CONTENTCOMPLETE -> Statement   {cons("COMPLETION-Statement")}
    CONTENTCOMPLETE -> Lvalue      {cons("COMPLETION-Lvalue")}
    CONTENTCOMPLETE -> Exp         {cons("COMPLETION-Exp")}

  lexical restrictions
    "return" "int" "float" "struct" "if" "else" "while" "sizeof" -/- [a-zA-Z]

  context-free priorities
    { "-" Exp -> Exp
      "+" Exp -> Exp } >
    {left:
      Exp "*" Exp -> Exp
    } >
    {left:
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    } >
    {non-assoc:
      Exp "<" Exp -> Exp
    } >
    {left:
      Exp "&&" Exp -> Exp
    }

  )

module MiniC-Lexical
exports
  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]*            -> ID           
    [0-9]+                             -> INT          
    [0-9]+ [eE] [0-9]+                 -> FLOAT        
    [0-9]+ "." [0-9]+ ( [eE] [0-9]+ )? -> FLOAT        
    "." [0-9]+ ( [eE] [0-9]+ )?        -> FLOAT        
    [0-9]+ "." ( [eE] [0-9]+ )?        -> FLOAT        
    [\ \t\n\r]                         -> LAYOUT       
    Comment                            -> LAYOUT       
    "//" ~[\n\r]* [\n\r] | EOF         -> Comment      
    BlockComment                       -> Comment      
    "/*" CommentPart* "*/"             -> BlockComment 
    ~[\/\*]                            -> CommentPart  
    Asterisk                           -> CommentPart  
    ForwardSlash                       -> CommentPart  
    BlockComment                       -> CommentPart  
    [\*]                               -> Asterisk     
    [\/]                               -> ForwardSlash 
                                       -> EOF          

  lexical restrictions
    ID -/- [a-zA-Z0-9\_]
    INT -/- [0-9]
    FLOAT -/- [0-9]
    Asterisk -/- [\/]
    ForwardSlash -/- [\*]
    EOF -/- ~[]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    Comment? -/- [\/] . [\/]
    Comment? -/- [\/] . [\*]

  lexical syntax
    "auto"     -> ID {reject}
    "break"    -> ID {reject}
    "case"     -> ID {reject}
    "char"     -> ID {reject}
    "const"    -> ID {reject}
    "continue" -> ID {reject}
    "default"  -> ID {reject}
    "do"       -> ID {reject}
    "double"   -> ID {reject}
    "else"     -> ID {reject}
    "enum"     -> ID {reject}
    "extern"   -> ID {reject}
    "float"    -> ID {reject}
    "for"      -> ID {reject}
    "goto"     -> ID {reject}
    "if"       -> ID {reject}
    "int"      -> ID {reject}
    "long"     -> ID {reject}
    "register" -> ID {reject}
    "return"   -> ID {reject}
    "short"    -> ID {reject}
    "signed"   -> ID {reject}
    "sizeof"   -> ID {reject}
    "static"   -> ID {reject}
    "struct"   -> ID {reject}
    "switch"   -> ID {reject}
    "typedef"  -> ID {reject}
    "union"    -> ID {reject}
    "unsigned" -> ID {reject}
    "void"     -> ID {reject}
    "volatile" -> ID {reject}
    "while"    -> ID {reject}
    "null"     -> ID {reject}
    "NULL"     -> ID {reject}

module MiniC
imports MiniC-Lexical MiniC-ContextFree

exports
  context-free start-symbols
    Program