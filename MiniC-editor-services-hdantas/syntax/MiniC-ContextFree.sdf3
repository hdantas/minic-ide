module MiniC-ContextFree

  imports
    MiniC-Lexical
 
  templates
    Program.File                      = < <TypeDec*> <VarDec*> <FunctionDec*> <Exp> >
    //Program.File                      = < <TypeDec*; text="{\tStructDeclaration\n"> <VarDec*; text="\tVariable Declaration\n"> <FunctionDec*; text="\tFuncion Declaration\n"> <Exp; text="\tResult\n}"> >
    
    TypeDec.StructDec                 = < struct <ID; text="StructName"> { <VarDec*; text="StructMembers"> } ; >

    VarDec.VarDec                     = < <Type; text="Type"> <ID; text="VarName"> ; >
    VarDec.ArrayDec                   = < <ArrayType; text="Type"> <ID; text="ArrayName"> [ <INT; text="NumberElements"> ] ; >
    
  
    FunctionDec.FunctionDef           = < <Type; text="ReturnType"> <ID; text="FuncName"> ( <Parameter*; separator=", ", text="Arguments"> ) { <VarDec*; text="\\n\\tVariable Declaration\\n"> <Statement*; text="Function Body\\n"> return <Exp; text="Result\\n"> ; } >
    
    Parameter.Arg                     = < <Type; text="Type"> <ID; text="Name"> >
    Parameter.ArrayArg                = < <ArrayType; text="Type">  <ID; text="Name"> [ ] >
    
    ArrayType.Int                     = < int >
    ArrayType.Float                   = < float >
    Type.Array                        = < <ArrayType; text="Type"> >
    Type.Struct                       = < struct <ID; text="StructName">  >

    Statement.Assignment              = < <ID; text="Var"> = <Exp; hide> ; >
    Statement.ArrayAssignment         = < <ID; text="ArrayName"> [ <Exp; text="Index"> ] = <Exp; hide> ; >
    Statement.StructMemberAssignment  = < <ID; text="StructName"> . <ID; text="StructMember"> = <Exp; hide> ; >
    Statement.IfElse                  = < if ( <Exp; text="Condition"> ) <Statement; text=" "> else <Statement; text=" "> >
    Statement.While                   = < while ( <Exp; text="Condition"> ) <Statement; hide> >
    Statement.PrintfInt               = < printf ( " %i " , <Exp; text="IntegerVar"> ) ; >
    Statement.PrinfFloat              = < printf ( " %f " , <Exp; text="FloatVar"> ) ; >
    Statement.CodeBlock               = < { <Statement*; text="{\t}"> } >

    Exp.IntConst                      = < <INT; text="Integer"> >
    Exp.FloatConst                    = < <FLOAT; text="Float"> >
    
    Lvalue.Var                        = < <ID; text="VarName"> >
    Lvalue.StructMember               = < <Lvalue; text="StructName"> . <Lvalue; text="StructMember"> > {left}
    Lvalue.ArrayVar                   = < <ID; text="ArrayName"> [ <Exp; text="Index"> ] >
    Exp                               = < <Lvalue> >
    
    Exp.And                           = < <Exp; text="Value"> && <Exp; text="Value"> > {left}
    Exp.Lt                            = [ [Exp; text="Value"] < [Exp; text="Value"] ] {non-assoc}
    Exp.Gt                            = [ [Exp; text="Value"] > [Exp; text="Value"] ] {non-assoc}
    Exp.Add                           = < <Exp; text="Addend"> + <Exp; text="Addend"> > {left}
    Exp.Subtract                      = < <Exp; text="Minuend" > - <Exp; text="Subtrahend"> > {left}
    Exp.Multiply                      = < <Exp; text="Multiplicand"> * <Exp; text="Multiplier"> > {left}
    Exp.Divide                        = < <Exp; text="Dividend"> / <Exp; text="Divisor"> > {left}
    Exp.Not                           = < ! <Exp; text="Boolean"> >
    Exp                               = < ( <Exp; text="Expression"> ) > {bracket}
    Exp.Sizeof                        = < sizeof ( <Exp; text="Datatype"> ) >
    Exp.Call                          = < <ID; text="FuncName"> ( <Exp*; separator=","> ) >
  
  
  context-free priorities

      { left:
        Exp.Multiply
        Exp.Divide
      } >  { left:
        Exp.Add
        Exp.Subtract
      } > { non-assoc:
        Exp.Lt
        Exp.Gt
      } > { left:
        Exp.And
      }
      
    template options
      keyword -/- [a-zA-Z]
    
    
    