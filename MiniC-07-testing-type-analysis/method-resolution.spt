module method-resolution

language MiniC
start symbol Program


// We covered name resolution tests already in a previous assignment.
// We skipped method names in that assignment, since method name resolution
// requires type analysis. Consider the following test case as an example:

// The type of the callee expression determines the class in which the method declaration can be found.
// In this example, the expression new Foo() is of type ClassType(Foo) and the corresponding class Foo
// contains a method declaration for run().

// You should come up with test cases for the resolution of method names.
// Start with simple test cases, but keep in mind that method name resolution
// is quite complex and that coverage is the main criterion for your grade.
// It is important to think about forward and backward references,
// resolution in the presence of homonyms and overriding, and the influence
// of class hierarchies on resolution.
 
// Field/Struct variables resolution was completed in Day 05: Testing Name Analysis

test method name resolution [[
  int [[foo]]() { return 0; }
  int main(){ return [[foo]](); }
  0
]] resolve #2 to #1

test method name resolution [[
  int [[foo]]() { return 0; }
  int foo(int a) { return a; }
  int main(){ return [[foo]](); }
  0
]] resolve #2 to #1

test method name resolution [[
  int foo() { return 0; }
  int [[foo]](int a) { return a; }
  int main(){ return [[foo]](1); }
  0
]] resolve #2 to #1

test method name resolution [[
  int foo() { return 0; }
  int main(){ return [[foo]](1); }
  int [[foo]](int a) { return a; }
  0
]] resolve #1 to #2

test method name resolution [[
  int main(){ return [[foo]](1); }
  int foo() { return 0; }
  int [[foo]](int a) { return a; }
  0
]] resolve #1 to #2

